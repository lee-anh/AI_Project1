#ifndef AGENT
#define AGENT

#include <chrono>
#include <fstream>
#include <iostream>
#include <queue>
#include <string>
#include <vector>

#include "Checker.h"
#include "Heuristic.h"
#include "Node.h"
#include "NodeCompare.h"
#include "ReachedTree.h"

using namespace std;

/// @brief Agent conducts the A* search and finds a solution to the A* problem
class Agent {
 public:
  /// @brief Agent constructor which
  /// @param puzzleRoot initial state
  /// @param heuristic which to use
  /// @param outputFileName where to output data to
  Agent(Node* puzzleRoot, int heuristic, string outputFileName);

  /// @brief perform A* search
  /// @return last node if there is a solution
  Node* AStarSearch();

  /// @brief getter for time to solve a problem from start to finish
  /// @return
  int getTimeToSolve();

  /// @brief getter for number of nodes generated by the A* search
  /// @return
  long getTotalNumberOfNodes();

  /// @brief getter for number of parent nodes/expanded nodes
  /// @return
  long getTotalNumberOfParentNodes();

  /// @brief getter for solution depth
  /// @return
  int getDeepestDepth();

  /// @brief calculates the average branching factor
  /// @return
  float getAverageBranchingFactor();

  /// @brief calculates the average frontier size
  /// @return
  float getAverageFrontierSize();

 private:
  // instance variables
  Node* root;
  Node* current;
  int deepestDepth;
  int heuristic;
  string outputFileName;
  long sumBranchingFactor;
  long sumFrontierSize;
  int timeToSolve;
  long totalNumberOfNodes;
  long totalNumberOfParentNodes;

  // frontier
  priority_queue<Node*, vector<Node*>, NodeCompare> pq;

  // don't explore states that we've already reached before
  ReachedTree* reached;

  /// @brief helper to expand, adds a child node
  /// @param puzzle to find the child of
  /// @param move which child to find
  void addChild(Puzzle* puzzle, int move);

  /// @brief expand the current node by finding and adding possible children
  void expand();

  /// @brief write solution data to log
  /// @param solution the last node
  /// @param solved whether or not the puzzle was solvable
  void outputToLog(Node* solution, bool solved);

  /// @brief construct the solution
  /// @param solution the last node
  /// @return a proposed solution of how to get from inital state to goal state (reversed order)
  vector<int> backtraceSolution(Node* solution);
};

#endif